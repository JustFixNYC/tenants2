# This Dockerfile can be used to deploy a production instance
# to Heroku.
#
# It's similar to the base Dockerfile--in fact,
# the first several lines should be identical--but it contains
# extra directives to install all dependencies, generate static
# assets, and so forth, so that the final container is completely
# self-contained.

FROM python:3.7.0

ENV NODE_VERSION=8

RUN curl -sL https://deb.nodesource.com/setup_${NODE_VERSION}.x | bash - \
  && curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | bash - \
  && curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add - \
  && echo "deb https://dl.yarnpkg.com/debian/ stable main" | tee /etc/apt/sources.list.d/yarn.list \
  && apt-get update \
  && apt-get install -y \
    nodejs \
    yarn \
    # Install the CLIs for databases so we can use 'manage.py dbshell'.
    postgresql-client \
    # Add support for GeoDjango.
    binutils \
    libproj-dev \
    gdal-bin \
    # This is for CircleCI.
    ca-certificates \
    git-lfs \
    # These are for WeasyPrint.
    libcairo2 libpango-1.0-0 libpangocairo-1.0-0 libgdk-pixbuf2.0-0 libffi-dev shared-mime-info \
  && rm -rf /var/lib/apt/lists/* \
  && pip install pipenv

ENV PATH /tenants2/node_modules/.bin:/node_modules/.bin:$PATH

# This is where we start to deviate from the base Dockerfile.

# The way we're using lots of layers here is intentional, as
# we're first installing our dependencies--which don't change
# very often--and then copying over the rest of our source code,
# which does change often. This means we can iterate faster
# because we e.g. don't have to re-install all our dependencies
# if we change a single line of code (it also reduces the amount
# of data we need to transfer to send our image somewhere, if
# the destination already has cached layers from previous
# builds we've sent).

ENV NODE_ENV=production

COPY Pipfile* requirements.production.txt /tmp/tenants2/

WORKDIR /tmp/tenants2

RUN pipenv install --system --keep-outdated \
  && pip install -r requirements.production.txt

WORKDIR /tenants2

COPY package*.json /tenants2/

# Make sure we run as a non-root user.
RUN useradd -m myuser
RUN chown myuser /tenants2
USER myuser

RUN yarn install --frozen-lockfile

ADD --chown=myuser:myuser . /tenants2/

ARG GIT_REVISION
ARG IS_GIT_REPO_PRISTINE

ENV GIT_REVISION=$GIT_REVISION
ENV IS_GIT_REPO_PRISTINE=$IS_GIT_REPO_PRISTINE

RUN yarn build \
  #
  # We specify 'USE_DEVELOPMENT_DEFAULTS=yup' and a fake
  # database URL for this single command so that it can be run
  # without raising any errors about undefined environment
  # variables (this is fine, since collectstatic doesn't need
  # to use any production env vars or access the database).
  #
  && USE_DEVELOPMENT_DEFAULTS=yup \
     DATABASE_URL=postgres://it-does-not/matter \
     python manage.py collectstatic

CMD gunicorn --bind 0.0.0.0:$PORT project.wsgi
