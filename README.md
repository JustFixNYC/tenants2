[![CircleCI](https://circleci.com/gh/JustFixNYC/tenants2.svg?style=svg)](https://circleci.com/gh/JustFixNYC/tenants2)
[![Maintainability](https://api.codeclimate.com/v1/badges/de475123649c132f858b/maintainability)](https://codeclimate.com/github/JustFixNYC/tenants2/maintainability)
[![Test Coverage](https://api.codeclimate.com/v1/badges/de475123649c132f858b/test_coverage)](https://codeclimate.com/github/JustFixNYC/tenants2/test_coverage)

This is an attempt at creating a new Tenants app for JustFix.

## Quick start

You'll need Python 3.7.0 and [pipenv][], as well as Node 8.

First create an environment file and optionally edit it as you
see fit:

```
cp .justfix-env.sample .justfix-env
```

Then set up the front-end and configure it to
continuously re-build itself as you change the source code:

```
npm install
npm start
```

Then, in a separate terminal, you'll want to instantiate
your Python virtual environment and enter it:

```
pipenv install --dev --python 3.7
pipenv shell
```

(Note that if you're on Windows and have `bash`, you
might want to run `pipenv run bash` instead of
`pipenv shell`, to avoid a bug whereby command-line
history doesn't work with `cmd.exe`.)

Then start the app:

```
python manage.py migrate
python manage.py runserver
```

Then visit http://localhost:8000/ in your browser.

### Production dependencies

Some of this project's dependencies are cumbersome
to install on some platforms, so they're not installed
by default.

However, they are present in the Docker development
environment (described below), and they are
required to develop some functionality, as well as
for production deployment. They can be installed via:

```
pipenv run pip install -r requirements.production.txt
```

These dependencies are described below.

#### WeasyPrint

[WeasyPrint][] is used for PDF generation. If it's
not installed during development, then any PDF-related
functionality will fail.

Instructions for installing it can be found on the
[WeasyPrint installation docs][].

[WeasyPrint]: http://weasyprint.org/
[WeasyPrint installation docs]: https://weasyprint.readthedocs.io/en/latest/install.html

## Running tests

To run the back-end Python/Django tests, use:

```
pytest
```

To run the front-end Node/TypeScript tests, use:

```
npm test
```

You can also use `npm run test:watch` to have Jest
continuously watch the front-end tests for changes and
re-run them as needed.

## Environment variables

For help on environment variables related to the
Django app, run:

```
python manage.py envhelp
```

Alternatively, you can examine
[project/justfix_environment.py](project/justfix_environment.py).

For the Node front-end, the only environment variable that
matters right now is `NODE_ENV`, which can be set to
`production` for production or any other value for
development.

## GraphQL

The communication between server and client occurs via [GraphQL][]
and has been structured for type safety. This means that we'll
get notified if there's ever a mismatch between the server's
schema and the queries the client is generating.

[GraphQL]: https://graphql.org/

### Server-side GraphQL schema

The server uses [Graphene-Django][] for its GraphQL needs.

The JSON representation of its schema is in `schema.json` and
is automatically regenerated by the development server,
though developers can manually regenerate it via
`python manage.py graphql_schema --indent 2` if needed.

[Graphene-Django]: http://docs.graphene-python.org/projects/django/en/latest/

### Client-side GraphQL queries

Client-side GraphQL code is generated as follows:

1. Raw queries are in `frontend/lib/queries/` and given a `.graphql`
   extension.  Currently, they must consist of **one** query,
   mutation, or fragment that has the same name as the base name of the file.
   For instance, if the file is called `SimpleQuery.graphql`,
   then the contained query should be called `SimpleQuery`, e.g.:

    ```graphql
    query SimpleQuery($thing: String) {
        hello(thing: $thing)
    }
    ```

2. The querybuilder, which runs as part of `npm start`, will notice
   changes to any of these raw queries *or* the server's `schema.json`,
   and do the following:

    1. It runs [Apollo Code Generation][] to validate the raw queries
       against the server's GraphQL schema and create TypeScript
       interfaces for them.

    2. For queries and mutations, it adds a function to the TypeScript
       interfaces that is responsible for performing the query in a
       type-safe way.
       
    3. The resultant TypeScript interfaces and/or function is written
       to a file that is created next to the original `.graphql` file
       (e.g., `SimpleQuery.ts`).

    If the developer prefers not to rely on `npm start`
    to automatically rebuild queries for them, they can also manually
    run `node querybuilder.js`.

At this point the developer can import the final TS file and use the query.

[Apollo Code Generation]: https://github.com/apollographql/apollo-cli#code-generation

## Running the server in production mode

Occasionally you might want to run the server in production mode on your
local system, without actually deploying it, to ensure that everything
works in production.

One quick way to do this is to run:

```
python manage.py runprodserver
```

## Developing with Docker

You can alternatively develop the app via [Docker][], which
means you don't have to install any dependencies. However,
Docker takes a bit of time to learn how to use.

To set everything up, run:

```
bash docker-update.sh
```

Then run:

```
docker-compose up
```

This will start up all services and you can visit
http://localhost:8000/ to visit the app.

[Docker]: https://docs.docker.com/install/

### Updating the containers

Whenever you update your repository via e.g. `git pull` or
`git checkout`, you should update your containers by running:

```
bash docker-update.sh
```

### Starting over

If your Docker setup appears to be in an irredeemable state
and `bash docker-update.sh` doesn't fix it--or
if you just want to free up extra disk space used up by
the app--you can destroy everything by running:

```
docker-compose down -v
```

Note that this may delete all the data in your
instance's database.

At this point you can re-run `bash docker-update.sh` to set
everything up again.

### Accessing the app container

To access the app container, run:

```sh
docker-compose run app bash
```

This will run an interactive bash session inside the main app container.
In this container, the `/tenants2` directory is mapped to the root of
the repository on your host; you can run any command, like `python manage.py`
or `pytest`, from there.

### A `manage.py` shortcut

Note that if you don't have Django installed on your host system, you
can just run `python manage.py` directly from outside the container--the
`manage.py` script has been modified to run itself in a Docker container
if it detects that Django isn't installed.

## Deployment

The app uses the [twelve-factor methodology][], so
deploying it should be relatively straightforward.

At the time of this writing, however, the app's
runtime environment does need *both* Python and Node
to execute properly, which could complicate matters.

### Deploying to Heroku via Docker

It's possible to deploy to Heroku using their
[Container Registry and Runtime][].  To push the
container to their registry, run:

```
heroku container:push --recursive
```

Then to deploy it, run:

```
heroku container:release web
```

You'll likely want to use [Heroku Postgres][] as your
database backend.

#### Locally testing the production Docker container

You can build the production Docker container locally with:

```
docker build -f Dockerfile.web -t tenants2 .
```

Then you can run it:

```
docker run --rm -it -e PORT=8000 -p 8000:8000 -e USE_DEVELOPMENT_DEFAULTS=yup tenants2
```

You can visit the server at http://localhost:8000/ and even create accounts
and such, as it uses an ephemeral SQLite database built-in to the
container, but the data will go away once the container is removed.

[pipenv]: https://docs.pipenv.org/
[twelve-factor methodology]: https://12factor.net/
[multiple buildpacks]: https://devcenter.heroku.com/articles/using-multiple-buildpacks-for-an-app
[Heroku Postgres]: https://www.heroku.com/postgres
[Container Registry and Runtime]: https://devcenter.heroku.com/articles/container-registry-and-runtime
