/** @jest-environment node */

import * as path from "path";

import { getGlobalAutogenContext } from "../querybuilder";
import { GraphQlFile } from "../graphql-file";
import { findStaleTypescriptFiles } from "../stale-ts-files";
import {
  autogenerateGraphQlFiles,
  generateBlankTypeLiterals,
} from "../autogen-graphql";
import { withMockConsoleLog } from "../../lib/tests/util";

const RE_RUN_MSG = 'Please re-run "node querybuilder.js".';

describe("querybuilder", () => {
  it("should generate TS files without throwing", () => {
    // This is really just a smoke test. We used to actually run the whole
    // GraphQL-to-TypeScript code generation pipeline here back when we
    // stored the TS in version control to make sure that the TS was up-to-date,
    // but that's not needed anymore now that we always run the pipeline as
    // part of our build process.
    GraphQlFile.fromDir().forEach((query) => query.generateTsCode());
  });

  it("should not have generated any TS files that lack graphQL queries/fragments", () => {
    const files = findStaleTypescriptFiles()
      .map((f) => path.basename(f))
      .join(", ");

    if (files.length) {
      throw new Error(`Stale GraphQL TS files exist (${files}). ${RE_RUN_MSG}`);
    }
  });

  it("should have up-to-date autogenerated GraphQL queries", () => {
    // Sometimes this logs information about deprecated things, which we want
    // removed from the test output.
    const ctx = withMockConsoleLog(() => getGlobalAutogenContext());

    const { filesChanged } = autogenerateGraphQlFiles(ctx, true);
    if (filesChanged.length) {
      throw new Error(
        `Autogenerated GraphQL files are out of date (${filesChanged}). ${RE_RUN_MSG}`
      );
    }
  });

  it("should generate blank type literals without throwing", () => {
    generateBlankTypeLiterals(getGlobalAutogenContext());
  });
});
