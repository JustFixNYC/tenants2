import * as fs from "fs";

/** Returns whether a source string contains any of the given strings. */
export function strContains(source: string, ...strings: string[]): boolean {
  for (let string of strings) {
    if (source.indexOf(string) >= 0) {
      return true;
    }
  }
  return false;
}

/** Returns a list of all fragments the given GraphQL code uses. */
export function getGraphQlFragments(source: string): string[] {
  const re = /\.\.\.([A-Za-z0-9]+)/g;
  const results = [];
  let m = null;

  do {
    m = re.exec(source);
    if (m) {
      results.push(m[1]);
    }
  } while (m);

  return results;
}

/**
 * Return whether our command-line arguments represent any of the given
 * options.
 */
export function argvHasOption(...opts: string[]): boolean {
  for (let opt of opts) {
    if (process.argv.indexOf(opt) !== -1) {
      return true;
    }
  }
  return false;
}

/** A simple debouncer to aid in file watching. */
export function debouncer(
  func: (events: any[], paths: string[]) => void,
  debounceMs: number
) {
  let timeout: any = null;
  let events: any[] = [];
  let paths: string[] = [];
  const dispatchFunc = () => {
    const finalEvents = events;
    const finalPaths = paths;
    events = [];
    paths = [];
    func(finalEvents, finalPaths);
  };

  return (event: any, path: string) => {
    events = [...events, event];
    paths = [...paths, path];
    if (timeout !== null) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(dispatchFunc, debounceMs);
  };
}

/**
 * A custom error that indicates an error from a tool, which
 * users can take steps to resolve.
 */
export class ToolError extends Error {}

/**
 * If the given list of files is non-empty, log a console message whose
 * content is generated by calling the given function, passing it the
 * number of items in the list and the given pluralization string.
 */
export function reportChanged(
  files: string[],
  createMsg: (count: number, s: "s" | "") => string,
  log = console.log
) {
  if (files.length > 0) {
    log(createMsg(files.length, files.length > 1 ? "s" : ""));
  }
}

/**
 * Write the given file to disk, but only if its new contents are
 * different from its existing contents.
 *
 * Returns true if the file's contents have changed, false otherwise.
 */
export function writeFileIfChangedSync(
  path: string,
  contents: string,
  dryRun: boolean = false
): boolean {
  if (
    fs.existsSync(path) &&
    fs.readFileSync(path, { encoding: "utf-8" }) === contents
  ) {
    return false;
  }
  if (!dryRun) {
    fs.writeFileSync(path, contents, { encoding: "utf-8" });
  }
  return true;
}

/**
 * Combine the given list of glob expressions into a single
 * glob expression.
 */
export function combineGlobs(globs: string[]): string {
  return globs.length === 1 ? globs[0] : `{${globs.join(",")}}`;
}

/**
 * Return whether the given path is a non-empty file.
 */
export function isNonEmptyFileSync(path: string): boolean {
  return fs.statSync(path).size > 0;
}
