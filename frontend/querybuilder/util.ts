import * as fs from 'fs';

/** Returns whether a source string contains any of the given strings. */
export function strContains(source: string, ...strings: string[]): boolean {
  for (let string of strings) {
    if (source.indexOf(string) >= 0) {
      return true;
    }
  }
  return false;
}

/** Returns a list of all fragments the given GraphQL code uses. */
export function getGraphQlFragments(source: string): string[] {
  const re = /\.\.\.([A-Za-z0-9]+)/g;
  const results = [];
  let m = null;

  do {
    m = re.exec(source);
    if (m) {
      results.push(m[1]);
    }
  } while (m);

  return results;
}

/**
 * Return whether our command-line arguments represent any of the given
 * options.
 */
export function argvHasOption(...opts: string[]): boolean {
  for (let opt of opts) {
    if (process.argv.indexOf(opt) !== -1) {
      return true;
    }
  }
  return false;
}

/** A simple debouncer to aid in file watching. */
export function debouncer(func: (events: any[], paths: string[]) => void, debounceMs: number) {
  let timeout: any = null;
  let events: any[] = [];
  let paths: string[] = [];
  const dispatchFunc = () => {
    const finalEvents = events;
    const finalPaths = paths;
    events = [];
    paths = [];
    func(finalEvents, finalPaths)
  };

  return (event: any, path: string) => {
    events = [...events, event];
    paths = [...paths, path];
    if (timeout !== null) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(dispatchFunc, debounceMs);
  };
}

/**
 * A custom error that indicates an error from a tool, which
 * users can take steps to resolve.
 */
export class ToolError extends Error {}

/**
 * If the given list of files is non-empty, log a console message whose
 * content is generated by calling the given function, passing it the
 * number of items in the list and the given pluralization string.
 */
export function reportChanged(
  files: string[],
  createMsg: (count: number, s: 's'|'') => string,
  log = console.log
) {
  if (files.length > 0) {
    log(createMsg(files.length, files.length > 1 ? 's' : ''));
  }
}

/**
 * Write the given file to disk, but only if its new contents are
 * different from its existing contents.
 * 
 * Returns true if the file's contents have changed, false otherwise.
 */
export function writeFileIfChangedSync(path: string, contents: string, dryRun: boolean = false): boolean {
  if (fs.existsSync(path) && fs.readFileSync(path, { encoding: 'utf-8' }) === contents) {
    return false;
  }
  if (!dryRun) {
    fs.writeFileSync(path, contents, { encoding: 'utf-8' });
  }
  return true;
}

/**
 * Combine the given list of glob expressions into a single
 * glob expression.
 */
export function combineGlobs(globs: string[]): string {
  return globs.length === 1 ? globs[0] : `{${globs.join(',')}}`
}
