@charset "utf-8";
@import "../../node_modules/bulma/bulma.sass";
@import "./_colors.scss";
@import "./_safe-mode.scss";

html[data-safe-mode-no-js] {
    // Don't show the hamburger at all, since people
    // will just be confused by its lack of interactivity.
    .navbar-burger {
        display: none;
    }
}

html:not([data-safe-mode-no-js]) .hero nav.navbar .is-active {
    &.navbar-menu, .navbar-dropdown {
        animation: jf-slidedown 0.5s;
    }
}

.hero nav.navbar {
    background: $justfix-blue;

    .navbar-item:focus, .navbar-link:focus, .navbar-burger:focus {
        outline: 2px dashed white;
    }

    .navbar-item, .navbar-link {
        color: white;
    }

    .navbar-link::after {
        border-color: white;
    }

    .is-active {
        .navbar-item:focus, .navbar-link:focus:not([role="button"]) {
            outline: 2px dashed $justfix-blue;
        }

        .navbar-item, .navbar-link {
            color: $justfix-blue;
        }

        // This handles the extremely weird case where the hamburger
        // is active, but the browser window is also wide enough to
        // not be showing the menu bar.
        //
        // Most significantly, this is the case in safe mode, when
        // we show both the hamburger and all dropdowns simultaneously,
        // and have no ability to change the DOM via JS.
        //
        // This is probably a symptom of how horrible all this CSS is.
        @media screen and (min-width: $desktop) {
            .navbar-end > .navbar-item:not(:hover) {
                color: white;
                outline-color: white;
            }
        }

        .navbar-link::after {
            border-color: $justfix-blue;
        }
    }

    a.navbar-item:hover,
    a.navbar-item.is-active,
    .navbar-link:hover,
    .navbar-link.is-active {
        color: $justfix-blue;
    }

    .navbar-link:hover::after,
    .navbar-link.is-active::after {
        border-color: $justfix-blue;
    }

    .navbar-burger {
        color: white;
    }
}

.button:focus {
    outline: 1px dashed rgba(0, 0, 0, 0.5);
    outline-offset: -5px;
}

.jf-hero.hero.is-fullheight .hero-body {
    align-items: flex-start;
}

// https://css-tricks.com/focus-styles-non-interactive-elements/
[data-jf-is-noninteractive] {
    outline: none;
}

// Bulma is supposed to support this, but at the moment it
// doesn't:
// https://github.com/jgthms/bulma/issues/150
//
// Until it does, we'll use this from:
// https://webaim.org/techniques/css/invisiblecontent/
.jf-sr-only {
    position: absolute;
    left: -10000px;
    top: auto;
    width: 1px;
    height: 1px;
    overflow: hidden;
}

// This is basically the same as react-aria-modal's default
// underlay styling.
.jf-modal-underlay {
    position: fixed;
    top: 0px;
    left: 0px;
    width: 100%;
    height: 100%;
    z-index: 1050;
    overflow: hidden auto;
    text-align: center;
    background: rgba(0, 0, 0, 0.5);
    cursor: pointer;
}

// This is quite similar to Bulma's .modal styling.
.jf-modal-dialog {
    display: flex;
    align-items: center;
    flex-direction: column;
    justify-content: center;
    position: relative;
    overflow: hidden;
    height: 100%;
    cursor: default;
}

.jf-radio.radio + .jf-radio.radio {
    // This undoes Bulma's default .radio+.radio styling.
    margin-left: 0;
}

.jf-radio, .jf-checkbox, .jf-single-checkbox {
    display: flex;
    min-height: 2em;

    input {
        min-width: 1.4em;
        min-height: 1.4em;
        margin-left: 0.5em;
        margin-right: 0.5em;
    }

    input:focus {
        outline-offset: 4px;
        outline: 1px dashed black;
    }
}

.jf-radio, .jf-checkbox {
    align-items: center;
}

.jf-single-checkbox {
    align-items: top;
}

.jf-modal-animate {
    animation-duration: 0.5s;
    animation-name: jf-fadein;
}

@keyframes jf-slidedown {
    from {
        max-height: 0;
        padding-top: 0;
        padding-bottom: 0;
        overflow: hidden;
    }

    to {
        max-height: 1000px;
    }
}

@keyframes jf-fadein {
    from {
        opacity: 0;
    }

    to {
        opacity: 1.0;
    }
}

.jf-loc-preview iframe {
    width: 100%;
    min-height: 20em;
}

.jf-autocomplete-is-highlighted {
    color: white;
    background-color: $justfix-blue;
}

.jf-autocomplete-is-selected {
    font-weight: bold;
}

.jf-autocomplete-field .control {
    position: relative;
}

.jf-autocomplete-field ul {
    position: absolute;
    top: 2em;
    left: 0;
    width: 100%;
    background: white;
    border: 1px solid black;
    z-index: 100;
    display: none;
}

.jf-autocomplete-field ul.jf-autocomplete-open {
    display: block;
}

.jf-autocomplete-field ul li {
    padding: 0.5rem;
}

.jf-issue-area-link {
    color: $button-text-color;
    display: block;
    border: 1px solid $button-text-hover-background-color;
    text-align: center;
    padding: 0.5em;
    height: 100%;

    img {
        width: 48px;
        height: 48px;
        overflow: hidden;
    }
}

.jf-issue-area-link:hover {
    color: $button-text-hover-color;
    background: $button-text-hover-background-color;
}

@keyframes jf-pulse {
    from {
        background: transparent;
    }

    to {
        background: yellow;
    }
}

.jf-issue-area-link.jf-highlight {
    animation: jf-pulse 1s;
    animation-iteration-count: infinite;
    animation-direction: alternate;
}
